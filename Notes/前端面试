1，实现继承的5种方式
    （1），使用原型链继承，子类构造方法的原型指向父类构造方法的实例，缺点是父类中引用类型的属性会被共享；
    （2），借用构造方法继承，在子类型构造函数中调用父类型构造函数，并将this指向子类的new出来的对象上，实际上是每次都将父类方法实例化一次
        缺点是父类中相同方法也需要被创建多次，浪费内存，且子类访问不到父类原型的属性和方法了。
    （3），组合继承，结合了原型链继承和构造方法继承两种方式。先使用构造方法继承，再将子类构造方法的原型指向父类构造方法的实例;
        存在的问题，此时子类的constructor不再是自身的构造函数了；
    （4），经典继承，利用Object.create()方法，用法：object.create(animal,{name:{value:"猫咪",writable:true}})，缺点同使用原型链继承，实例间会被共享；
    （5），寄生组合式继承，在组合继承的基础上，不再直接将子类构造方法的原型指向父类构造方法的实例，而是指向父类构造方法的原型创建的一个副本;
2，在JS中arguments对象的理解
    （1）arguments对象实际上是所在函数的内置类数组对象；
    （2）每个函数都有arguments属性，表示函数的实参集合。arguments不是数组而是一个对象，但是和数组很相似，所以称之为类数组对象。不能显式的创建，只有在函数开始时才可用；
    （3）arguments的属性，length：表示实参的数量；callee:引用函数自身，可以实现匿名函数的递归；Symbol迭代器
    （4）arguments可以检测到参数的个数，用来实现函数重载;
3，判断数据类型的方法
    （1）typeof 123:，"number"。
        适用于Number，String,Boolean,Function,undefined;
        不适用于Array,Object,Null,Date,RegExp,Error,都会被判断为Object
    （2）instanceof：判断在其原型链上是否存在这一个构造函数的prototype属性，但是判断不了，Number、string、Boolean的类型（使用new Number()方法新建的可以判断出来）。
    
