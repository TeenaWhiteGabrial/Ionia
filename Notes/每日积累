1，实现继承的5种方式
    （1），使用原型链继承，子类构造方法的原型指向父类构造方法的实例，缺点是父类中引用类型的属性会被共享；
    （2），借用构造方法继承，在子类型构造函数中调用父类型构造函数，并将this指向子类的new出来的对象上，实际上是每次都将父类方法实例化一次
        缺点是父类中相同方法也需要被创建多次，浪费内存，且子类访问不到父类原型的属性和方法了。
    （3），组合继承，结合了原型链继承和构造方法继承两种方式。先使用构造方法继承，再将子类构造方法的原型指向父类构造方法的实例;
        存在的问题，此时子类的constructor不再是自身的构造函数了；
    （4），经典继承，利用Object.create()方法，用法：object.create(animal,{name:{value:"猫咪",writable:true}})，缺点同使用原型链继承，实例间会被共享；
    （5），寄生组合式继承，在组合继承的基础上，不再直接将子类构造方法的原型指向父类构造方法的实例，而是指向父类构造方法的原型创建的一个副本;
2，在JS中arguments对象的理解
    （1）arguments对象实际上是所在函数的内置类数组对象；
    （2）每个函数都有arguments属性，表示函数的实参集合。arguments不是数组而是一个对象，但是和数组很相似，所以称之为类数组对象。不能显式的创建，只有在函数开始时才可用；
    （3）arguments的属性，length：表示实参的数量；callee:引用函数自身，可以实现匿名函数的递归；Symbol迭代器
    （4）arguments可以检测到参数的个数，用来实现函数重载;
3，判断数据类型的方法
    （1）typeof 123:，"number"。
        适用于Number，String,Boolean,Function,undefined;
        不适用于Array,Object,Null,Date,RegExp,Error,都会被判断为Object
    （2）instanceof：判断在其原型链上是否存在这一个构造函数的prototype属性，但是判断不了，Number、string、Boolean的类型（使用new Number()方法新建的可以判断出来）。
        检测构造函数的prototype属性是否在实例的原型链上。语法：Object instanceof Contructor
    （3）tostring：Object的原型方法，调用该方法默认返回当前对象的Class,这是一个内部属性。用法：Object.tostring，Object.prototype.call('123')//返回结果：Object 适用于Number，String
    （4）使用原型中的construct属性（原型中的constructor属性指向构造函数），判断不了null、undefined，因为他们没有constructor
4,Ajax的原生写法
    var xhr=window.XMLHttpRequest?new XMLHttpRequest():ActiveXObject('Microsoft.XMLHTTP');
    xhr.open('get',url,true);
    xhr.send();
    xhr.onreadystatechange=()=>{
        if(xhr.readystate==4){
            if(xhr.status=200){
                var data=xhr.responseTEXT;
                return data;
            }
        }
    }
5,对象深拷贝、浅拷贝
    对象浅拷贝是指对于对象地址的复制，没有开辟新的栈；
    对象深拷贝的方法：
        （1）JSON.stringify/parse的方法
            JSON.stringify,JSON序列化，将对象序列化为字符串；
            JSON.parse,JSON反序列化，将字符串反序列化为JSON对象；
            存在的问题：function类型的属性无法被正常序列化;
        （2）使用递归方法，对每一层数据都实现一次创建对象、对象赋值的操作。可以深拷贝疏忽组、对象、以及带函数的对象
            function DeepClone(item){
                const target = item.constructor === Array?[]:{};//判断复制的目标是对象还是数组
                for(let keys in item){
                    if(item.hasOwnProperty(keys)){
                        if(item[keys]&&typeof item[keys] ==='object'){//如果值是对象，就递归一下
                            target[keys]=item[keys].constructor === Array?[]:{};
                            target[keys]=DeepClone(item);
                        }else{
                            target[keys]=item[keys]
                        }
                    }
                }

                return target;
            }
        （3）对于数组来说，还可以有：ES6的Array.from()、[...Array]、concat、selice、等，但是都只能实现第一层的拷贝
6，图片懒加载和预加载
    图片懒加载：先将图片的src设定为一张简单的loading图片，真实的src设定为一个自定义属性中（data-src），等到图片元素进入到可视窗口的时候，再更新src值;
    图片预加载：浏览器会缓存请求过的图片，基于此，在还不需要加载图片的时候下载图片缓存起来不可见，等到需要的时候再去加载；
7，实现页面加载进度条
    （1）要素：
        JQuery中的$.loading()以及$.loaded();
        document.onreadystatechange事件用来监听加载的状态变化；
        document.readystate,页面当前文档的状态，
            uninitialized,还未开始载入；
            loading，载入中；
            interactive，已载入，文档和用户可以开始交互；
            complete，载入完成；
    （2）实现百分比加载，待补充；
8，this关键字,表示当前执行代码的环境对象，可以分为全局环境和函数环境；
    （1）在函数内部，this的取值取决于函数被调用时的运行环境。this对象指向的是函数当前的执行环境对象，执行环境是会在事件循环过程中变化的，因此this在函数环境中是属于运行时的。
        例：
        var name="Tom";
        var obj={
            name:"iceburg",
            say:function(){
                alert(this.name);
            }
            sub:{
                say:function(){
                    alert(this.name);
                }
            }
        }

        obj.say();//输出iceburg;
        obj.sub.say();//输出undefined
        var say=obj.say();
        say();//输出Tom;
    （2）事件回调函数
        当函数被当做事件触发的回调函数执行时，this是指向该触发事件对应的元素。
        例如：
            var handle={
                name:"Tom",
                register:function(){
                    console.log(this.name);
                }
            }

        $('#registerBtn').on('click',handle.register);//输出undefined
        要想实现输出Tom,可以使用bind方法。
        $('#registerBtn').on('click',handle.register.bind(handle));
        若是使用箭头函数，则无需使用bind。箭头函数中的this本就是对应定义时所在的对象；
    （3）构造函数
        在构造函数中this指向的是其实例对象，可参考使用new命令实例化构造函数A的过程中会发生什么。
    （4）bind，更改函数体中的this指向，并返回一个新的函数；
    （5）call和apply，变更函数中的this指向，可附带参数列表。apply是以参数数组的形式

9，函数式编程

10，函数柯里化，就是将低阶函数转化为高阶函数。是一种预加载函数的能力，是一种对参数的缓存
    例如：function(x,y){
            return x+y;
        }柯里化之后，变为：
        function(x){
            return function(y){
                x+y;
            }
        }

11，手动实现parseInt
    function _parseInt(str,radix){
            var res = 0;
            if(typeof str !="string" && typeof str !="number"){
                return NaN;
            }
            str =String(str).trim().split(".")[0];//String.trim(),trim的作用是截取中间的非空白字符，作为一个New出来的对象存储在heap内存中（堆内存）

            let len = str.length;
            if(!len){
                return NaN;
            }
            if(!radix){
                return radix = 10;
            }
            if(typeof radix !=="number" || radix < 2 || radix >36){
                return NaN;
            }
            for(let i = 0; i < len; i++){
                let arr = str.split("");//split，截取字符串为数组。
                res += Math.floor(arr[i])*Math.pow(radix,i)//Math.floor,向下取整。有将字符串转化为Number的功能
            }
            return res;
        }
12，同源策略：如果两个页面的协议、域名、端口都相同，则两个页面具有相同的源。非同源的两个页面之间发送Ajax请求会被浏览器拦截。
    同源策略的限制：
        （1），Cookie、LocalStorage和IndexDB无法读取;
        （2），DOM无法获得;
        （3），AJAX请求不能发送;

13,判断两个对象是否相等，先判断内存地址是否相等，再使用递归对每个属性进行判断;
14,事件委托、代理。
    实现方法：addEventListener(type,listener,userCapture);//userCapture用来表示是在捕获阶段触发(true)，还是在冒泡阶段触发(false),默认为false。
    事件委托的优点：
        （1），提高性能，每一个函数都会占用内存空间，只需添加一个事件处理程序代理所有时间，所占用的内存空间更少。
        （2），动态监听，使用事件委托可以自动绑定动态添加的元素，即新增的节点不需要主动添加也可以一样具有和其他元素一样的事件。
15,window.onload和domcontentloaded
    window.onload,页面上所有的DOM、样式表、脚本、图片等等都已经加载完成了；
    domcontentloaded,页面上的DOM加载完成。
16,浏览器页面加载渲染过程（拿到HTML文件之后的操作）
    （1）   构建DOM树。读取HTML文档，将byte转化为字符，转化为tokens（标签）、转化为节点、以节点构建DOM树；
            构建CSSOM树。
            加载JS。在构建DOM树的过程中，如果遇到了JS，则会阻塞DOM树的构件，初衷是为了提高性能，减少不必要的DOM创建。
    （2），构建渲染树，由DOM树和CSSOM合并构建。计算每个可见元素的布局，输出到绘制流程，将像素渲染到屏幕上。
    （3）重绘，屏幕的一部分重绘，但是节点的空间位置和大小并不发生变化;
        重排，渲染树的节点发生变化，重新生成渲染树，重新布局。当节点的大小和空间位置发生改变时触发重排（添加删除节点、更改位置、更改尺寸等）
17,for in迭代和for of迭代的区别
    （1）for in取key,可以用于数组和对象属性的遍历，主要是为了遍历对象。
    （2）for of取value，可以用于数组的遍历、类数组对象、字符串、Set、Map、iterator对象等;
    （3）foreach，遍历数组，但是不能使用break中断循环、也不能使用return 返回到外层函数。
18,原生实现bind
19,async/await，ES6的语法
    aysnc,声明一个异步函数，在异步的处理上，是generator的语法糖;
    await,每到一个await的时候，程序需要等待执行后面的程序。await只能在async里面用，后面的语句可以是对象、数字、字符串等等
20，generator函数和yield表达式
    （1）generator函数是ES6提供的一种异步编程解决方案，特点如下：
        1),generator函数在function和函数名之间有一个*,在function的右上角;
        2),generator函数的返回是一个Iterator对象,直接运行generator函数并不会立即运行;
        3),generator函数内部可以使用yield表达式，定义不同的状态;
        4),可以依次使用.next方法，遍历Generator函数内部的每一个状态。
    （2）yield表达式，定义状态，暂停执行，yield本身并没有返回值；
    （3）yield*表达式，用来在Generator函数里面调用另一个Generator函数;
    （4）next()方法的参数，yield本身并没有返回值，总是undefined，可以在next方法中传参用来表示上一个yield表达式的返回值。
21,立即执行函数和使用场景
    立即执行函数就是立即执行(function(){.....})(),好处是隔离作用域，可以在插件中使用，可以与闭包配合使用。
22,前端常用的设计模式
    （1）单例模式：保证一个类只有一个实例，提供一个访问它的全局访问点。
            需求：一些对象我们往往只需要一个，比如线程池、全局缓存、浏览器中的window对象、登录浮窗等。
            实现：用一个变量标识当前是否为某个类创建过对象，如果是，则在下一次获取这个类的实例时，直接返回之前创建的对象。
            优点：
                1)可以用来划分命名空间，减少全局变量的数量。
                2)可以被实例化，且实例化一次之后，再次实例化生成的也是第一个实例。
            代码：
                var Singleton=function(name){
                    this.name=name;
                    this.instance=null;
                }

                Single.prototype.getName=function(){
                    return this.name;
                }

                Single.getSingle=function(name){
                    if(!this.instance){
                        this.instance=new Singleton(name);
                    }
                    return this.instance;
                }

                var SingleA=Single.getSingle("aaa");
                var SingleB=Single.getSingle("bbb");
    （2）观察者模式：对象间的一对多的依赖关系。
            需求：当一个对象的状态发生变化时，所有依赖于他的对象都将得到通知；
23,iframe的缺点
    （1）
24,数组问题
    （1）数组去重：
        1).先使用Array.sort()将数组排序，再比较相邻的两个元素，如果不相同则去除掉。
            代码：function distinct(arr){
                arr=arr.sort();
                let NewArr=[arr[0]];
                for(let i=1;i<length;i++){
                    arr[i]!==arr[i-1]&&NewArr.push(arr[i]);
                }
                return NewArr;
            }
        2).ES6新增Set结构，不允许重复。可以